[
["tidyr.html", "Chapter 4 Tidy Data 4.1 Learning Objectives 4.2 Resources 4.3 Setup 4.4 Tidy Data 4.5 Pivot Functions 4.6 Tidy Verbs 4.7 Pipes 4.8 More Complex Example 4.9 Glossary 4.10 Exercises", " Chapter 4 Tidy Data 4.1 Learning Objectives 4.1.1 Basic Understand the concept of tidy data Be able to convert between long and wide formats using pivot functions pivot_longer() pivot_wider() Be able to use the 4 basic tidyr verbs gather() separate() spread() unite() Be able to chain functions using pipes 4.1.2 Advanced Be able to use regular expressions to separate complex columns 4.2 Resources Tidy Data Chapter 12: Tidy Data in R for Data Science Chapter 18: Pipes in R for Data Science Data wrangling cheat sheet 4.3 Setup # libraries needed library(tidyverse) library(dataskills) set.seed(8675309) # makes sure random numbers are reproducible 4.4 Tidy Data 4.4.1 Three Rules Each variable must have its own column Each observation must have its own row Each value must have its own cell This table has three observations per row and the total_meanRT column contains two values. Table 4.1: Untidy table id score_1 score_2 score_3 rt_1 rt_2 rt_3 total_meanRT 1 4 3 7 857 890 859 14 (869) 2 3 1 1 902 900 959 5 (920) 3 2 5 4 757 823 901 11 (827) 4 6 2 6 844 788 624 14 (752) 5 1 7 2 659 764 690 10 (704) This is the tidy version. Table 4.1: Tidy table id trial rt score total mean_rt 1 1 857 4 14 869 1 2 890 3 14 869 1 3 859 7 14 869 2 1 902 3 5 920 2 2 900 1 5 920 2 3 959 1 5 920 3 1 757 2 11 827 3 2 823 5 11 827 3 3 901 4 11 827 4 1 844 6 14 752 4 2 788 2 14 752 4 3 624 6 14 752 5 1 659 1 10 704 5 2 764 7 10 704 5 3 690 2 10 704 4.4.2 Wide versus long Data tables can be in wide format or long format (and sometimes a mix of the two). Wide data are where all of the observations about one subject are in the same row, while long data are where each observation is on a separate row. You often need to convert between these formats to do different types of analyses or data processing. Imagine a study where each subject completes a questionnaire with three items. Each answer is an observation of that subject. You are probably most familiar with data like this in a wide format, where the subject id is in one column, and each of the three item responses is in its own column. Table 4.2: Wide data id Q1 Q2 Q3 A 1 2 3 B 4 5 6 The same data can be represented in a long format by creating a new column that specifies what item the observation is from and a new column that specifies the value of that observation. Table 4.3: Long data id item value A Q1 1 B Q1 4 A Q2 2 B Q2 5 A Q3 3 B Q3 6 Create a long version of the following table. id fav_colour fav_animal Lisa red echidna Robbie orange babirusa Steven green frog Answer Your answer doesn’t need to have the same column headers or be in the same order. id fav answer Lisa colour red Lisa animal echidna Robbie colour orange Robbie animal babirusa Steven colour green Steven animal frog 4.5 Pivot Functions The pivot functions allow you to transform a data table from wide to long or long to wide in one step. 4.5.1 Load Data We will used the dataset personality from the dataskills package (or download the data from personality.csv). These data are from a 5-factor (personality) personality questionnaire. Each question is labelled with the domain (Op = openness, Co = conscientiousness, Ex = extroversion, Ag = agreeableness, and Ne = neuroticism) and the question number. data(&quot;personality&quot;, package = &quot;dataskills&quot;) user_id date Op1 Ne1 Ne2 Op2 Ex1 Ex2 Co1 Co2 Ne3 Ag1 Ag2 Ne4 Ex3 Co3 Op3 Ex4 Op4 Ex5 Ag3 Co4 Co5 Ne5 Op5 Ag4 Op6 Co6 Ex6 Ne6 Co7 Ag5 Co8 Ex7 Ne7 Co9 Op7 Ne8 Ag6 Ag7 Co10 Ex8 Ex9 0 2006-03-23 3 4 0 6 3 3 3 3 0 2 1 3 3 2 2 1 3 3 1 3 0 3 6 1 0 6 3 1 3 3 3 3 NA 3 0 2 NA 3 1 2 4 1 2006-02-08 6 0 6 0 0 0 0 0 0 0 6 6 6 0 6 0 0 0 0 6 6 0 6 0 6 0 6 6 6 6 0 6 0 6 6 0 6 0 6 0 6 2 2005-10-24 6 0 6 0 0 0 0 0 0 0 6 6 5 1 5 1 1 1 1 5 5 1 5 1 5 1 5 5 5 5 1 5 1 5 5 1 5 1 5 1 5 5 2005-12-07 6 4 4 4 2 3 3 3 1 4 0 2 5 3 5 3 6 6 1 5 5 4 2 4 1 4 3 1 1 0 1 4 2 4 5 1 2 1 5 4 5 8 2006-07-27 6 1 2 6 2 3 5 4 0 6 5 3 3 4 5 3 6 3 0 5 5 1 5 6 6 6 0 0 3 2 3 1 0 3 5 1 3 1 3 3 5 108 2006-02-28 3 2 1 4 4 4 4 3 1 5 4 2 3 4 4 3 3 3 4 3 3 1 4 5 4 5 4 1 4 5 4 2 2 4 4 1 4 3 5 4 2 4.5.2 pivot_longer() pivot_longer() converts a wide data table to long format by converting the headers from specified columns into the values of new columns, and combining the values of those columns into a new condensed column. cols refers to the columns you want to make long You can refer to them by their names, like col1, col2, col3, col4 or col1:col4 or by their numbers, like 8, 9, 10 or 8:10. names_to is what you want to call the new columns that the gathered column headers will go into; it’s “domain” and “qnumber” in this example. names_sep is an optional argument if you have more than one value for names_to. It specifies the characters or position to split the values of the cols headers. values_to is what you want to call the values in the columns ...; they’re “score” in this example. personality_long &lt;- pivot_longer( data = personality, cols = Op1:Ex9, # columns to make long names_to = c(&quot;domain&quot;, &quot;qnumber&quot;), # new column names for headers names_sep = 2, # how to split the headers values_to = &quot;score&quot; # new column name for values ) %&gt;% glimpse() ## Rows: 615,000 ## Columns: 5 ## $ user_id &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ date &lt;date&gt; 2006-03-23, 2006-03-23, 2006-03-23, 2006-03-23, 2006-03-23, … ## $ domain &lt;chr&gt; &quot;Op&quot;, &quot;Ne&quot;, &quot;Ne&quot;, &quot;Op&quot;, &quot;Ex&quot;, &quot;Ex&quot;, &quot;Co&quot;, &quot;Co&quot;, &quot;Ne&quot;, &quot;Ag&quot;, &quot;… ## $ qnumber &lt;chr&gt; &quot;1&quot;, &quot;1&quot;, &quot;2&quot;, &quot;2&quot;, &quot;1&quot;, &quot;2&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;1&quot;, &quot;2&quot;, &quot;4&quot;, &quot;… ## $ score &lt;dbl&gt; 3, 4, 0, 6, 3, 3, 3, 3, 0, 2, 1, 3, 3, 2, 2, 1, 3, 3, 1, 3, 0… You can pipe a data table to glimpse() at the end to have a quick look at it. It will still save to the object. What would you set names_sep to in order to split the cols headers listed below into the results? cols names_to names_sep A_1, A_2, B_1, B_2 c(\"condition\", \"version\") A B 1 2 _ A1, A2, B1, B2 c(\"condition\", \"version\") A B 1 2 _ cat-day&amp;pre, cat-day&amp;post, cat-night&amp;pre, cat-night&amp;post, dog-day&amp;pre, dog-day&amp;post, dog-night&amp;pre, dog-night&amp;post c(\"pet\", \"time\", \"condition\") - &amp; - 4.5.3 pivot_wider() We can also go from long to wide format using the pivot_wider() function. names_from is the columns that contain your new column headers. values_from is the column that contains the values for the new columns. names_sep is the character string used to join names if names_from is more than one column. personality_wide &lt;- pivot_wider( data = personality_long, names_from = c(domain, qnumber), values_from = score, names_sep = &quot;&quot; ) %&gt;% glimpse() ## Rows: 15,000 ## Columns: 43 ## $ user_id &lt;dbl&gt; 0, 1, 2, 5, 8, 108, 233, 298, 426, 436, 685, 807, 871, 881, 9… ## $ date &lt;date&gt; 2006-03-23, 2006-02-08, 2005-10-24, 2005-12-07, 2006-07-27, … ## $ Op1 &lt;dbl&gt; 3, 6, 6, 6, 6, 3, 3, 6, 6, 3, 4, 5, 5, 5, 6, 4, 1, 2, 5, 6, 4… ## $ Ne1 &lt;dbl&gt; 4, 0, 0, 4, 1, 2, 3, 4, 0, 3, 3, 3, 2, 1, 1, 3, 4, 5, 2, 4, 5… ## $ Ne2 &lt;dbl&gt; 0, 6, 6, 4, 2, 1, 2, 3, 1, 2, 5, 5, 3, 1, 1, 1, 1, 6, 1, 2, 5… ## $ Op2 &lt;dbl&gt; 6, 0, 0, 4, 6, 4, 4, 0, 0, 3, 4, 3, 3, 4, 5, 3, 3, 4, 1, 6, 6… ## $ Ex1 &lt;dbl&gt; 3, 0, 0, 2, 2, 4, 4, 3, 5, 4, 1, 1, 3, 3, 1, 3, 5, 1, 0, 4, 1… ## $ Ex2 &lt;dbl&gt; 3, 0, 0, 3, 3, 4, 5, 2, 5, 3, 4, 1, 3, 2, 1, 6, 5, 3, 4, 4, 1… ## $ Co1 &lt;dbl&gt; 3, 0, 0, 3, 5, 4, 3, 4, 5, 3, 3, 3, 1, 5, 5, 4, 4, 5, 6, 4, 2… ## $ Co2 &lt;dbl&gt; 3, 0, 0, 3, 4, 3, 3, 4, 5, 3, 5, 3, 3, 4, 5, 1, 5, 4, 5, 2, 5… ## $ Ne3 &lt;dbl&gt; 0, 0, 0, 1, 0, 1, 4, 4, 0, 4, 2, 5, 1, 2, 5, 5, 2, 2, 1, 2, 5… ## $ Ag1 &lt;dbl&gt; 2, 0, 0, 4, 6, 5, 5, 4, 2, 5, 4, 3, 2, 4, 5, 3, 5, 5, 5, 4, 4… ## $ Ag2 &lt;dbl&gt; 1, 6, 6, 0, 5, 4, 5, 3, 4, 3, 5, 1, 5, 4, 2, 6, 5, 5, 5, 5, 2… ## $ Ne4 &lt;dbl&gt; 3, 6, 6, 2, 3, 2, 3, 3, 0, 4, 4, 5, 5, 4, 5, 3, 2, 5, 2, 4, 5… ## $ Ex3 &lt;dbl&gt; 3, 6, 5, 5, 3, 3, 3, 0, 6, 1, 4, 2, 3, 2, 1, 2, 5, 1, 0, 5, 5… ## $ Co3 &lt;dbl&gt; 2, 0, 1, 3, 4, 4, 5, 4, 5, 3, 4, 3, 4, 4, 5, 4, 2, 4, 5, 2, 2… ## $ Op3 &lt;dbl&gt; 2, 6, 5, 5, 5, 4, 3, 2, 4, 3, 3, 6, 5, 5, 6, 5, 4, 4, 3, 6, 5… ## $ Ex4 &lt;dbl&gt; 1, 0, 1, 3, 3, 3, 4, 3, 5, 3, 2, 0, 3, 3, 1, 2, NA, 4, 4, 4, … ## $ Op4 &lt;dbl&gt; 3, 0, 1, 6, 6, 3, 3, 0, 6, 3, 4, 5, 4, 5, 6, 6, 2, 2, 4, 5, 5… ## $ Ex5 &lt;dbl&gt; 3, 0, 1, 6, 3, 3, 4, 2, 5, 2, 2, 4, 2, 3, 0, 4, 5, 2, 3, 1, 1… ## $ Ag3 &lt;dbl&gt; 1, 0, 1, 1, 0, 4, 4, 4, 3, 3, 4, 4, 3, 4, 4, 5, 5, 4, 5, 3, 4… ## $ Co4 &lt;dbl&gt; 3, 6, 5, 5, 5, 3, 2, 4, 3, 1, 4, 3, 1, 2, 4, 2, NA, 5, 6, 1, … ## $ Co5 &lt;dbl&gt; 0, 6, 5, 5, 5, 3, 3, 1, 5, 1, 2, 4, 4, 4, 2, 1, 6, 4, 3, 1, 3… ## $ Ne5 &lt;dbl&gt; 3, 0, 1, 4, 1, 1, 4, 5, 0, 3, 4, 6, 2, 0, 1, 1, 0, 4, 3, 1, 5… ## $ Op5 &lt;dbl&gt; 6, 6, 5, 2, 5, 4, 3, 2, 6, 6, 2, 4, 3, 4, 6, 6, 6, 5, 3, 3, 5… ## $ Ag4 &lt;dbl&gt; 1, 0, 1, 4, 6, 5, 5, 6, 6, 6, 4, 2, 4, 5, 4, 5, 6, 4, 5, 6, 5… ## $ Op6 &lt;dbl&gt; 0, 6, 5, 1, 6, 4, 6, 0, 0, 3, 5, 3, 5, 5, 5, 2, 5, 1, 1, 6, 2… ## $ Co6 &lt;dbl&gt; 6, 0, 1, 4, 6, 5, 6, 5, 4, 3, 5, 5, 4, 6, 6, 1, 3, 4, 5, 4, 6… ## $ Ex6 &lt;dbl&gt; 3, 6, 5, 3, 0, 4, 3, 1, 6, 3, 2, 1, 4, 2, 1, 5, 6, 2, 1, 2, 1… ## $ Ne6 &lt;dbl&gt; 1, 6, 5, 1, 0, 1, 3, 4, 0, 4, 4, 5, 2, 1, 5, 6, 1, 2, 2, 3, 5… ## $ Co7 &lt;dbl&gt; 3, 6, 5, 1, 3, 4, NA, 2, 3, 3, 2, 2, 4, 2, 5, 2, 5, 5, 3, 1, … ## $ Ag5 &lt;dbl&gt; 3, 6, 5, 0, 2, 5, 6, 2, 2, 3, 4, 1, 3, 5, 2, 6, 5, 6, 5, 3, 3… ## $ Co8 &lt;dbl&gt; 3, 0, 1, 1, 3, 4, 3, 0, 1, 3, 2, 2, 1, 2, 4, 3, 2, 4, 5, 2, 6… ## $ Ex7 &lt;dbl&gt; 3, 6, 5, 4, 1, 2, 5, 3, 6, 3, 4, 3, 5, 1, 1, 6, 6, 3, 1, 1, 3… ## $ Ne7 &lt;dbl&gt; NA, 0, 1, 2, 0, 2, 4, 4, 0, 3, 2, 5, 1, 2, 5, 2, 2, 4, 1, 3, … ## $ Co9 &lt;dbl&gt; 3, 6, 5, 4, 3, 4, 5, 3, 5, 3, 4, 3, 4, 4, 2, 4, 6, 5, 5, 2, 2… ## $ Op7 &lt;dbl&gt; 0, 6, 5, 5, 5, 4, 6, 2, 1, 3, 2, 4, 5, 5, 6, 3, 6, 5, 2, 6, 5… ## $ Ne8 &lt;dbl&gt; 2, 0, 1, 1, 1, 1, 5, 4, 0, 4, 4, 5, 1, 2, 5, 2, 1, 5, 1, 2, 5… ## $ Ag6 &lt;dbl&gt; NA, 6, 5, 2, 3, 4, 5, 6, 1, 3, 4, 2, 3, 5, 1, 6, 2, 6, 6, 5, … ## $ Ag7 &lt;dbl&gt; 3, 0, 1, 1, 1, 3, 3, 5, 0, 3, 2, 1, 2, 3, 5, 6, 4, 4, 6, 6, 2… ## $ Co10 &lt;dbl&gt; 1, 6, 5, 5, 3, 5, 1, 2, 5, 2, 4, 3, 4, 4, 3, 2, 5, 5, 5, 2, 2… ## $ Ex8 &lt;dbl&gt; 2, 0, 1, 4, 3, 4, 2, 4, 6, 2, 4, 0, 4, 4, 1, 3, 5, 4, 3, 1, 1… ## $ Ex9 &lt;dbl&gt; 4, 6, 5, 5, 5, 2, 3, 3, 6, 3, 3, 4, 4, 3, 2, 5, 5, 4, 4, 0, 4… 4.6 Tidy Verbs The pivot functions above are relatively new functions that combine the four basic tidy verbs. You can also convert data between long and wide formats using these functions. Many researchers still use these functions and older code will not use the pivot functions, so it is useful to know how to interpret these. 4.6.1 gather() Much like pivot_longer(), gather() makes a wide data table long by creating a column for the headers and a column for the values. The main difference is that you cannot turn the headers into more than one column. key is what you want to call the new column that the gathered column headers will go into; it’s “question” in this example. It is like names_to in pivot_longer(), but can only take one value (multiple values need to be separated after separate()). value is what you want to call the values in the gathered columns; they’re “score” in this example. It is like values_to in pivot_longer(). ... refers to the columns you want to gather. It is like cols in pivot_longer(). The gather() function converts personality from a wide data table to long format, with a row for each user/question observation. The resulting data table should have the columns: user_id, date, question, and score. personality_gathered &lt;- gather( data = personality, key = &quot;question&quot;, # new column name for gathered headers value = &quot;score&quot;, # new column name for gathered values Op1:Ex9 # columns to gather ) %&gt;% glimpse() ## Rows: 615,000 ## Columns: 4 ## $ user_id &lt;dbl&gt; 0, 1, 2, 5, 8, 108, 233, 298, 426, 436, 685, 807, 871, 881, … ## $ date &lt;date&gt; 2006-03-23, 2006-02-08, 2005-10-24, 2005-12-07, 2006-07-27,… ## $ question &lt;chr&gt; &quot;Op1&quot;, &quot;Op1&quot;, &quot;Op1&quot;, &quot;Op1&quot;, &quot;Op1&quot;, &quot;Op1&quot;, &quot;Op1&quot;, &quot;Op1&quot;, &quot;Op1… ## $ score &lt;dbl&gt; 3, 6, 6, 6, 6, 3, 3, 6, 6, 3, 4, 5, 5, 5, 6, 4, 1, 2, 5, 6, … 4.6.2 separate() col is the column you want to separate into is a vector of new column names sep is the character(s) that separate your new columns. This defaults to anything that isn’t alphanumeric, like .,_-/: and is like the names_sep argument in pivot_longer(). Split the question column into two columns: domain and qnumber. There is no character to split on, here, but you can separate a column after a specific number of characters by setting sep to an integer. For example, to split “abcde” after the third character, use sep = 3, which results in c(\"abc\", \"de\"). You can also use negative number to split before the nth character from the right. For example, to split a column that has words of various lengths and 2-digit suffixes (like “lisa03”“,”amanda38\"), you can use sep = -2. personality_sep &lt;- separate( data = personality_gathered, col = question, # column to separate into = c(&quot;domain&quot;, &quot;qnumber&quot;), # new column names sep = 2 # where to separate ) %&gt;% glimpse() ## Rows: 615,000 ## Columns: 5 ## $ user_id &lt;dbl&gt; 0, 1, 2, 5, 8, 108, 233, 298, 426, 436, 685, 807, 871, 881, 9… ## $ date &lt;date&gt; 2006-03-23, 2006-02-08, 2005-10-24, 2005-12-07, 2006-07-27, … ## $ domain &lt;chr&gt; &quot;Op&quot;, &quot;Op&quot;, &quot;Op&quot;, &quot;Op&quot;, &quot;Op&quot;, &quot;Op&quot;, &quot;Op&quot;, &quot;Op&quot;, &quot;Op&quot;, &quot;Op&quot;, &quot;… ## $ qnumber &lt;chr&gt; &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;… ## $ score &lt;dbl&gt; 3, 6, 6, 6, 6, 3, 3, 6, 6, 3, 4, 5, 5, 5, 6, 4, 1, 2, 5, 6, 4… If you want to separate just at full stops, you need to use sep = \"\\\\.\", not sep = \".\". The two slashes escape the full stop, making it interpreted as a literal full stop and not the regular expression for any character. 4.6.3 unite() col is your new united column ... refers to the columns you want to unite sep is the character(s) that will separate your united columns Put the domain and qnumber columns back together into a new column named domain_n. Make it in a format like “Op_Q1”. personality_unite &lt;- unite( data = personality_sep, col = &quot;domain_n&quot;, # new column name domain, qnumber, # columns to unite sep = &quot;_Q&quot; # separation characters ) %&gt;% glimpse() ## Rows: 615,000 ## Columns: 4 ## $ user_id &lt;dbl&gt; 0, 1, 2, 5, 8, 108, 233, 298, 426, 436, 685, 807, 871, 881, … ## $ date &lt;date&gt; 2006-03-23, 2006-02-08, 2005-10-24, 2005-12-07, 2006-07-27,… ## $ domain_n &lt;chr&gt; &quot;Op_Q1&quot;, &quot;Op_Q1&quot;, &quot;Op_Q1&quot;, &quot;Op_Q1&quot;, &quot;Op_Q1&quot;, &quot;Op_Q1&quot;, &quot;Op_Q1… ## $ score &lt;dbl&gt; 3, 6, 6, 6, 6, 3, 3, 6, 6, 3, 4, 5, 5, 5, 6, 4, 1, 2, 5, 6, … 4.6.4 spread() You can reverse the processes above, as well. For example, you can convert data from long format into wide format. key is the column that contains your new column headers. It is like names_from in pivot_wider(), but can only take one value (multiple values need to be merged first using unite()). value is the column that contains the values in the new spread columns. It is like values_from in pivot_wider(). personality_spread &lt;- spread( data = personality_unite, key = domain_n, # column that contains new headers value = score # column that contains new values ) %&gt;% glimpse() ## Rows: 15,000 ## Columns: 43 ## $ user_id &lt;dbl&gt; 0, 1, 2, 5, 8, 108, 233, 298, 426, 436, 685, 807, 871, 881, 9… ## $ date &lt;date&gt; 2006-03-23, 2006-02-08, 2005-10-24, 2005-12-07, 2006-07-27, … ## $ Ag_Q1 &lt;dbl&gt; 2, 0, 0, 4, 6, 5, 5, 4, 2, 5, 4, 3, 2, 4, 5, 3, 5, 5, 5, 4, 4… ## $ Ag_Q2 &lt;dbl&gt; 1, 6, 6, 0, 5, 4, 5, 3, 4, 3, 5, 1, 5, 4, 2, 6, 5, 5, 5, 5, 2… ## $ Ag_Q3 &lt;dbl&gt; 1, 0, 1, 1, 0, 4, 4, 4, 3, 3, 4, 4, 3, 4, 4, 5, 5, 4, 5, 3, 4… ## $ Ag_Q4 &lt;dbl&gt; 1, 0, 1, 4, 6, 5, 5, 6, 6, 6, 4, 2, 4, 5, 4, 5, 6, 4, 5, 6, 5… ## $ Ag_Q5 &lt;dbl&gt; 3, 6, 5, 0, 2, 5, 6, 2, 2, 3, 4, 1, 3, 5, 2, 6, 5, 6, 5, 3, 3… ## $ Ag_Q6 &lt;dbl&gt; NA, 6, 5, 2, 3, 4, 5, 6, 1, 3, 4, 2, 3, 5, 1, 6, 2, 6, 6, 5, … ## $ Ag_Q7 &lt;dbl&gt; 3, 0, 1, 1, 1, 3, 3, 5, 0, 3, 2, 1, 2, 3, 5, 6, 4, 4, 6, 6, 2… ## $ Co_Q1 &lt;dbl&gt; 3, 0, 0, 3, 5, 4, 3, 4, 5, 3, 3, 3, 1, 5, 5, 4, 4, 5, 6, 4, 2… ## $ Co_Q10 &lt;dbl&gt; 1, 6, 5, 5, 3, 5, 1, 2, 5, 2, 4, 3, 4, 4, 3, 2, 5, 5, 5, 2, 2… ## $ Co_Q2 &lt;dbl&gt; 3, 0, 0, 3, 4, 3, 3, 4, 5, 3, 5, 3, 3, 4, 5, 1, 5, 4, 5, 2, 5… ## $ Co_Q3 &lt;dbl&gt; 2, 0, 1, 3, 4, 4, 5, 4, 5, 3, 4, 3, 4, 4, 5, 4, 2, 4, 5, 2, 2… ## $ Co_Q4 &lt;dbl&gt; 3, 6, 5, 5, 5, 3, 2, 4, 3, 1, 4, 3, 1, 2, 4, 2, NA, 5, 6, 1, … ## $ Co_Q5 &lt;dbl&gt; 0, 6, 5, 5, 5, 3, 3, 1, 5, 1, 2, 4, 4, 4, 2, 1, 6, 4, 3, 1, 3… ## $ Co_Q6 &lt;dbl&gt; 6, 0, 1, 4, 6, 5, 6, 5, 4, 3, 5, 5, 4, 6, 6, 1, 3, 4, 5, 4, 6… ## $ Co_Q7 &lt;dbl&gt; 3, 6, 5, 1, 3, 4, NA, 2, 3, 3, 2, 2, 4, 2, 5, 2, 5, 5, 3, 1, … ## $ Co_Q8 &lt;dbl&gt; 3, 0, 1, 1, 3, 4, 3, 0, 1, 3, 2, 2, 1, 2, 4, 3, 2, 4, 5, 2, 6… ## $ Co_Q9 &lt;dbl&gt; 3, 6, 5, 4, 3, 4, 5, 3, 5, 3, 4, 3, 4, 4, 2, 4, 6, 5, 5, 2, 2… ## $ Ex_Q1 &lt;dbl&gt; 3, 0, 0, 2, 2, 4, 4, 3, 5, 4, 1, 1, 3, 3, 1, 3, 5, 1, 0, 4, 1… ## $ Ex_Q2 &lt;dbl&gt; 3, 0, 0, 3, 3, 4, 5, 2, 5, 3, 4, 1, 3, 2, 1, 6, 5, 3, 4, 4, 1… ## $ Ex_Q3 &lt;dbl&gt; 3, 6, 5, 5, 3, 3, 3, 0, 6, 1, 4, 2, 3, 2, 1, 2, 5, 1, 0, 5, 5… ## $ Ex_Q4 &lt;dbl&gt; 1, 0, 1, 3, 3, 3, 4, 3, 5, 3, 2, 0, 3, 3, 1, 2, NA, 4, 4, 4, … ## $ Ex_Q5 &lt;dbl&gt; 3, 0, 1, 6, 3, 3, 4, 2, 5, 2, 2, 4, 2, 3, 0, 4, 5, 2, 3, 1, 1… ## $ Ex_Q6 &lt;dbl&gt; 3, 6, 5, 3, 0, 4, 3, 1, 6, 3, 2, 1, 4, 2, 1, 5, 6, 2, 1, 2, 1… ## $ Ex_Q7 &lt;dbl&gt; 3, 6, 5, 4, 1, 2, 5, 3, 6, 3, 4, 3, 5, 1, 1, 6, 6, 3, 1, 1, 3… ## $ Ex_Q8 &lt;dbl&gt; 2, 0, 1, 4, 3, 4, 2, 4, 6, 2, 4, 0, 4, 4, 1, 3, 5, 4, 3, 1, 1… ## $ Ex_Q9 &lt;dbl&gt; 4, 6, 5, 5, 5, 2, 3, 3, 6, 3, 3, 4, 4, 3, 2, 5, 5, 4, 4, 0, 4… ## $ Ne_Q1 &lt;dbl&gt; 4, 0, 0, 4, 1, 2, 3, 4, 0, 3, 3, 3, 2, 1, 1, 3, 4, 5, 2, 4, 5… ## $ Ne_Q2 &lt;dbl&gt; 0, 6, 6, 4, 2, 1, 2, 3, 1, 2, 5, 5, 3, 1, 1, 1, 1, 6, 1, 2, 5… ## $ Ne_Q3 &lt;dbl&gt; 0, 0, 0, 1, 0, 1, 4, 4, 0, 4, 2, 5, 1, 2, 5, 5, 2, 2, 1, 2, 5… ## $ Ne_Q4 &lt;dbl&gt; 3, 6, 6, 2, 3, 2, 3, 3, 0, 4, 4, 5, 5, 4, 5, 3, 2, 5, 2, 4, 5… ## $ Ne_Q5 &lt;dbl&gt; 3, 0, 1, 4, 1, 1, 4, 5, 0, 3, 4, 6, 2, 0, 1, 1, 0, 4, 3, 1, 5… ## $ Ne_Q6 &lt;dbl&gt; 1, 6, 5, 1, 0, 1, 3, 4, 0, 4, 4, 5, 2, 1, 5, 6, 1, 2, 2, 3, 5… ## $ Ne_Q7 &lt;dbl&gt; NA, 0, 1, 2, 0, 2, 4, 4, 0, 3, 2, 5, 1, 2, 5, 2, 2, 4, 1, 3, … ## $ Ne_Q8 &lt;dbl&gt; 2, 0, 1, 1, 1, 1, 5, 4, 0, 4, 4, 5, 1, 2, 5, 2, 1, 5, 1, 2, 5… ## $ Op_Q1 &lt;dbl&gt; 3, 6, 6, 6, 6, 3, 3, 6, 6, 3, 4, 5, 5, 5, 6, 4, 1, 2, 5, 6, 4… ## $ Op_Q2 &lt;dbl&gt; 6, 0, 0, 4, 6, 4, 4, 0, 0, 3, 4, 3, 3, 4, 5, 3, 3, 4, 1, 6, 6… ## $ Op_Q3 &lt;dbl&gt; 2, 6, 5, 5, 5, 4, 3, 2, 4, 3, 3, 6, 5, 5, 6, 5, 4, 4, 3, 6, 5… ## $ Op_Q4 &lt;dbl&gt; 3, 0, 1, 6, 6, 3, 3, 0, 6, 3, 4, 5, 4, 5, 6, 6, 2, 2, 4, 5, 5… ## $ Op_Q5 &lt;dbl&gt; 6, 6, 5, 2, 5, 4, 3, 2, 6, 6, 2, 4, 3, 4, 6, 6, 6, 5, 3, 3, 5… ## $ Op_Q6 &lt;dbl&gt; 0, 6, 5, 1, 6, 4, 6, 0, 0, 3, 5, 3, 5, 5, 5, 2, 5, 1, 1, 6, 2… ## $ Op_Q7 &lt;dbl&gt; 0, 6, 5, 5, 5, 4, 6, 2, 1, 3, 2, 4, 5, 5, 6, 3, 6, 5, 2, 6, 5… 4.7 Pipes Pipes are a way to order your code in a more readable format. Let’s say you have a small data table with 10 participant IDs, two columns with variable type A, and 2 columns with variable type B. You want to calculate the mean of the A variables and the mean of the B variables and return a table with 10 rows (1 for each participant) and 3 columns (id, A_mean and B_mean). One way you could do this is by creating a new object at every step and using that object in the next step. This is pretty clear, but you’ve created 6 unnecessary data objects in your environment. This can get confusing in very long scripts. # make a data table with 10 subjects data_original &lt;- tibble( id = 1:10, A1 = rnorm(10, 0), A2 = rnorm(10, 1), B1 = rnorm(10, 2), B2 = rnorm(10, 3) ) # gather columns A1 to B2 into &quot;variable&quot; and &quot;value&quot; columns data_gathered &lt;- gather(data_original, variable, value, A1:B2) # separate the variable column at the _ into &quot;var&quot; and &quot;var_n&quot; columns data_separated &lt;- separate(data_gathered, variable, c(&quot;var&quot;, &quot;var_n&quot;), sep = 1) # group the data by id and var data_grouped &lt;- group_by(data_separated, id, var) # calculate the mean value for each id/var data_summarised &lt;- summarise(data_grouped, mean = mean(value), .groups = &quot;drop&quot;) # spread the mean column into A and B columns data_spread &lt;- spread(data_summarised, var, mean) # rename A and B to A_mean and B_mean data &lt;- rename(data_spread, A_mean = A, B_mean = B) data ## # A tibble: 10 x 3 ## id A_mean B_mean ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 -0.594 1.02 ## 2 2 0.744 2.72 ## 3 3 0.931 3.93 ## 4 4 0.720 1.97 ## 5 5 -0.0281 1.95 ## 6 6 -0.0983 3.21 ## 7 7 0.126 0.926 ## 8 8 1.45 2.38 ## 9 9 0.298 1.66 ## 10 10 0.559 2.10 You can name each object data and keep replacing the old data object with the new one at each step. This will keep your environment clean, but I don’t recommend it because it makes it too easy to accidentally run your code out of order when you are running line-by-line for development or debugging. One way to avoid extra objects is to nest your functions, literally replacing each data object with the code that generated it in the previous step. This can be fine for very short chains. mean_petal_width &lt;- round(mean(iris$Petal.Width), 2) But it gets extremely confusing for long chains: # do not ever do this!! data &lt;- rename( spread( summarise( group_by( separate( gather( tibble( id = 1:10, A1 = rnorm(10, 0), A2 = rnorm(10, 1), B1 = rnorm(10, 2), B2 = rnorm(10,3)), variable, value, A1:B2), variable, c(&quot;var&quot;, &quot;var_n&quot;), sep = 1), id, var), mean = mean(value), .groups = &quot;drop&quot;), var, mean), A_mean = A, B_mean = B) The pipe lets you “pipe” the result of each function into the next function, allowing you to put your code in a logical order without creating too many extra objects. # calculate mean of A and B variables for each participant data &lt;- tibble( id = 1:10, A1 = rnorm(10, 0), A2 = rnorm(10, 1), B1 = rnorm(10, 2), B2 = rnorm(10,3) ) %&gt;% gather(variable, value, A1:B2) %&gt;% separate(variable, c(&quot;var&quot;, &quot;var_n&quot;), sep=1) %&gt;% group_by(id, var) %&gt;% summarise(mean = mean(value), .groups = &quot;drop&quot;) %&gt;% spread(var, mean) %&gt;% rename(A_mean = A, B_mean = B) You can read this code from top to bottom as follows: Make a tibble called data with id of 1 to 10, A1 of 10 random numbers from a normal distribution, A2 of 10 random numbers from a normal distribution, B1 of 10 random numbers from a normal distribution, B2 of 10 random numbers from a normal distribution; and then Gather to create variable and value column from columns A_1 to B_2; and then Separate the column variable into 2 new columns called varand var_n, separate at character 1; and then Group by columns id and var; and then Summarise and new column called mean as the mean of the value column for each group and drop the grouping; and then Spread to make new columns with the key names in var and values in mean; and then Rename to make columns called A_mean (old A) and B_mean (old B) You can make intermediate objects whenever you need to break up your code because it’s getting too complicated or you need to debug something. You can debug a pipe by highlighting from the beginning to just before the pipe you want to stop at. Try this by highlighting from data &lt;- to the end of the separate function and typing cmd-return. What does data look like now? Chain all the steps above using pipes. personality_reshaped &lt;- personality %&gt;% gather(&quot;question&quot;, &quot;score&quot;, Op1:Ex9) %&gt;% separate(question, c(&quot;domain&quot;, &quot;qnumber&quot;), sep = 2) %&gt;% unite(&quot;domain_n&quot;, domain, qnumber, sep = &quot;_Q&quot;) %&gt;% spread(domain_n, score) 4.8 More Complex Example 4.8.1 Load Data Get data on infant and maternal mortality rates from the dataskills package. If you don’t have the package, you can download them here: infant mortality maternal mortality data(&quot;infmort&quot;, package = &quot;dataskills&quot;) head(infmort) ## # A tibble: 6 x 3 ## Country Year `Infant mortality rate (probability of dying between birth a… ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Afghanist… 2015 66.3 [52.7-83.9] ## 2 Afghanist… 2014 68.1 [55.7-83.6] ## 3 Afghanist… 2013 69.9 [58.7-83.5] ## 4 Afghanist… 2012 71.7 [61.6-83.7] ## 5 Afghanist… 2011 73.4 [64.4-84.2] ## 6 Afghanist… 2010 75.1 [66.9-85.1] data(&quot;matmort&quot;, package = &quot;dataskills&quot;) head(matmort) ## # A tibble: 6 x 4 ## Country `1990` `2000` `2015` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1 340 [ 878 - 1 950] 1 100 [ 745 - 1 570] 396 [ 253 - 620] ## 2 Albania 71 [ 58 - 88] 43 [ 33 - 56] 29 [ 16 - 46] ## 3 Algeria 216 [ 141 - 327] 170 [ 118 - 241] 140 [ 82 - 244] ## 4 Angola 1 160 [ 627 - 2 020] 924 [ 472 - 1 730] 477 [ 221 - 988] ## 5 Argentina 72 [ 64 - 80] 60 [ 54 - 65] 52 [ 44 - 63] ## 6 Armenia 58 [ 51 - 65] 40 [ 35 - 46] 25 [ 21 - 31] 4.8.2 Wide to Long matmort is in wide format, with a separate column for each year. Change it to long format, with a row for each Country/Year observation. This example is complicated because the column names to gather are numbers. If the column names are non-standard (e.g., have spaces, start with numbers, or have special characters), you can enclose them in backticks (`) like the example below. matmort_long &lt;- matmort %&gt;% pivot_longer(cols = `1990`:`2015`, names_to = &quot;Year&quot;, values_to = &quot;stats&quot;) %&gt;% glimpse() ## Rows: 543 ## Columns: 3 ## $ Country &lt;chr&gt; &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Albania&quot;, &quot;Alba… ## $ Year &lt;chr&gt; &quot;1990&quot;, &quot;2000&quot;, &quot;2015&quot;, &quot;1990&quot;, &quot;2000&quot;, &quot;2015&quot;, &quot;1990&quot;, &quot;2000… ## $ stats &lt;chr&gt; &quot;1 340 [ 878 - 1 950]&quot;, &quot;1 100 [ 745 - 1 570]&quot;, &quot;396 [ 253 - … You can put matmort at the first argument to pivot_longer(); you don’t have to pipe it in. But when I’m working on data processing I often find myself needing to insert or rearrange steps and I constantly introduce errors by forgetting to take the first argument out of a pipe chain, so now I start with the original data table and pipe from there. Alternatively, you can use the gather() function. matmort_long &lt;- matmort %&gt;% gather(&quot;Year&quot;, &quot;stats&quot;, `1990`:`2015`) %&gt;% glimpse() ## Rows: 543 ## Columns: 3 ## $ Country &lt;chr&gt; &quot;Afghanistan&quot;, &quot;Albania&quot;, &quot;Algeria&quot;, &quot;Angola&quot;, &quot;Argentina&quot;, &quot;… ## $ Year &lt;chr&gt; &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990… ## $ stats &lt;chr&gt; &quot;1 340 [ 878 - 1 950]&quot;, &quot;71 [ 58 - 88]&quot;, &quot;216 [ 141 - 327]&quot;… 4.8.3 One Piece of Data per Column The data in the stats column is in an unusual format with some sort of confidence interval in brackets and lots of extra spaces. We don’t need any of the spaces, so first we’ll remove them with mutate(), which we’ll learn more about in the next lesson. The separate function will separate your data on anything that is not a number or letter, so try it first without specifying the sep argument. The into argument is a list of the new column names. matmort_split &lt;- matmort_long %&gt;% mutate(stats = gsub(&quot; &quot;, &quot;&quot;, stats)) %&gt;% separate(stats, c(&quot;rate&quot;, &quot;ci_low&quot;, &quot;ci_hi&quot;)) %&gt;% glimpse() ## Warning: Expected 3 pieces. Additional pieces discarded in 543 rows [1, 2, 3, 4, ## 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...]. ## Rows: 543 ## Columns: 5 ## $ Country &lt;chr&gt; &quot;Afghanistan&quot;, &quot;Albania&quot;, &quot;Algeria&quot;, &quot;Angola&quot;, &quot;Argentina&quot;, &quot;… ## $ Year &lt;chr&gt; &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990… ## $ rate &lt;chr&gt; &quot;1340&quot;, &quot;71&quot;, &quot;216&quot;, &quot;1160&quot;, &quot;72&quot;, &quot;58&quot;, &quot;8&quot;, &quot;8&quot;, &quot;64&quot;, &quot;46&quot;… ## $ ci_low &lt;chr&gt; &quot;878&quot;, &quot;58&quot;, &quot;141&quot;, &quot;627&quot;, &quot;64&quot;, &quot;51&quot;, &quot;7&quot;, &quot;7&quot;, &quot;56&quot;, &quot;34&quot;, … ## $ ci_hi &lt;chr&gt; &quot;1950&quot;, &quot;88&quot;, &quot;327&quot;, &quot;2020&quot;, &quot;80&quot;, &quot;65&quot;, &quot;9&quot;, &quot;10&quot;, &quot;74&quot;, &quot;61… The gsub(pattern, replacement, x) function is a flexible way to do search and replace. The example above replaces all occurances of the pattern \" \" (a space), with the replacement \"\" (nothing), in the string x (the stats column). Use sub() instead if you only want to replace the first occurance of a pattern. We only used a simple pattern here, but you can use more complicated regex patterns to replace, for example, all even numbers (e.g., gsub(“[:02468:]”, \"“,”id = 123456“)) or all occurances of the word colour in US or UK spelling (e.g., gsub(”colo(u)?r“,”**“,”replace color, colour, or colours, but not collors\")). 4.8.3.1 Handle spare columns with extra The previous example should have given you an error warning about “Additional pieces discarded in 543 rows”. This is because separate splits the column at the brackets and dashes, so the text 100[90-110] would split into four values c(“100”, “90”, “110”, \"“), but we only specified 3 new columns. The fourth value is always empty (just the part after the last bracket), so we are happy to drop it, but separate generates a warning so you don’t do that accidentally. You can turn off the warning by adding the extra argument and setting it to “drop”. Look at the help for ??tidyr::separate to see what the other options do. matmort_split &lt;- matmort_long %&gt;% mutate(stats = gsub(&quot; &quot;, &quot;&quot;, stats)) %&gt;% separate(stats, c(&quot;rate&quot;, &quot;ci_low&quot;, &quot;ci_hi&quot;), extra = &quot;drop&quot;) %&gt;% glimpse() ## Rows: 543 ## Columns: 5 ## $ Country &lt;chr&gt; &quot;Afghanistan&quot;, &quot;Albania&quot;, &quot;Algeria&quot;, &quot;Angola&quot;, &quot;Argentina&quot;, &quot;… ## $ Year &lt;chr&gt; &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990… ## $ rate &lt;chr&gt; &quot;1340&quot;, &quot;71&quot;, &quot;216&quot;, &quot;1160&quot;, &quot;72&quot;, &quot;58&quot;, &quot;8&quot;, &quot;8&quot;, &quot;64&quot;, &quot;46&quot;… ## $ ci_low &lt;chr&gt; &quot;878&quot;, &quot;58&quot;, &quot;141&quot;, &quot;627&quot;, &quot;64&quot;, &quot;51&quot;, &quot;7&quot;, &quot;7&quot;, &quot;56&quot;, &quot;34&quot;, … ## $ ci_hi &lt;chr&gt; &quot;1950&quot;, &quot;88&quot;, &quot;327&quot;, &quot;2020&quot;, &quot;80&quot;, &quot;65&quot;, &quot;9&quot;, &quot;10&quot;, &quot;74&quot;, &quot;61… 4.8.3.2 Set delimiters with sep Now do the same with infmort. It’s already in long format, so you don’t need to use gather, but the third column has a ridiculously long name, so we can just refer to it by its column number (3). infmort_split &lt;- infmort %&gt;% separate(3, c(&quot;rate&quot;, &quot;ci_low&quot;, &quot;ci_hi&quot;), extra = &quot;drop&quot;) %&gt;% glimpse() ## Rows: 5,044 ## Columns: 5 ## $ Country &lt;chr&gt; &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;… ## $ Year &lt;dbl&gt; 2015, 2014, 2013, 2012, 2011, 2010, 2009, 2008, 2007, 2006, 2… ## $ rate &lt;chr&gt; &quot;66&quot;, &quot;68&quot;, &quot;69&quot;, &quot;71&quot;, &quot;73&quot;, &quot;75&quot;, &quot;76&quot;, &quot;78&quot;, &quot;80&quot;, &quot;82&quot;, &quot;… ## $ ci_low &lt;chr&gt; &quot;3&quot;, &quot;1&quot;, &quot;9&quot;, &quot;7&quot;, &quot;4&quot;, &quot;1&quot;, &quot;8&quot;, &quot;6&quot;, &quot;4&quot;, &quot;3&quot;, &quot;4&quot;, &quot;7&quot;, &quot;… ## $ ci_hi &lt;chr&gt; &quot;52&quot;, &quot;55&quot;, &quot;58&quot;, &quot;61&quot;, &quot;64&quot;, &quot;66&quot;, &quot;69&quot;, &quot;71&quot;, &quot;73&quot;, &quot;75&quot;, &quot;… Wait, that didn’t work at all! It split the column on spaces, brackets, and full stops. We just want to split on the spaces, brackets and dashes. So we need to manually set sep to what the delimiters are. Also, once there are more than a few arguments specified for a function, it’s easier to read them if you put one argument on each line. {#regex} You can use regular expressions to separate complex columns. Here, we want to separate on dashes and brackets. You can separate on a list of delimiters by putting them in parentheses, separated by “|”. It’s a little more complicated because brackets have a special meaning in regex, so you need to “escape” the left one with two backslashes “\\”. infmort_split &lt;- infmort %&gt;% separate( col = 3, into = c(&quot;rate&quot;, &quot;ci_low&quot;, &quot;ci_hi&quot;), extra = &quot;drop&quot;, sep = &quot;(\\\\[|-|])&quot; ) %&gt;% glimpse() ## Rows: 5,044 ## Columns: 5 ## $ Country &lt;chr&gt; &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;… ## $ Year &lt;dbl&gt; 2015, 2014, 2013, 2012, 2011, 2010, 2009, 2008, 2007, 2006, 2… ## $ rate &lt;chr&gt; &quot;66.3 &quot;, &quot;68.1 &quot;, &quot;69.9 &quot;, &quot;71.7 &quot;, &quot;73.4 &quot;, &quot;75.1 &quot;, &quot;76.8 &quot;… ## $ ci_low &lt;chr&gt; &quot;52.7&quot;, &quot;55.7&quot;, &quot;58.7&quot;, &quot;61.6&quot;, &quot;64.4&quot;, &quot;66.9&quot;, &quot;69.0&quot;, &quot;71.2… ## $ ci_hi &lt;chr&gt; &quot;83.9&quot;, &quot;83.6&quot;, &quot;83.5&quot;, &quot;83.7&quot;, &quot;84.2&quot;, &quot;85.1&quot;, &quot;86.1&quot;, &quot;87.3… 4.8.3.3 Fix data types with convert That’s better. Notice the next to Year, rate, ci_low and ci_hi. That means these columns hold characters (like words), not numbers or integers. This can cause problems when you try to do thigs like average the numbers (you can’t average words), so we can fix it by adding the argument convert and setting it to TRUE. infmort_split &lt;- infmort %&gt;% separate(col = 3, into = c(&quot;rate&quot;, &quot;ci_low&quot;, &quot;ci_hi&quot;), extra = &quot;drop&quot;, sep = &quot;(\\\\[|-|])&quot;, convert = TRUE) %&gt;% glimpse() ## Rows: 5,044 ## Columns: 5 ## $ Country &lt;chr&gt; &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;… ## $ Year &lt;dbl&gt; 2015, 2014, 2013, 2012, 2011, 2010, 2009, 2008, 2007, 2006, 2… ## $ rate &lt;dbl&gt; 66.3, 68.1, 69.9, 71.7, 73.4, 75.1, 76.8, 78.6, 80.4, 82.3, 8… ## $ ci_low &lt;dbl&gt; 52.7, 55.7, 58.7, 61.6, 64.4, 66.9, 69.0, 71.2, 73.4, 75.5, 7… ## $ ci_hi &lt;dbl&gt; 83.9, 83.6, 83.5, 83.7, 84.2, 85.1, 86.1, 87.3, 88.9, 90.7, 9… Do the same for matmort. matmort_split &lt;- matmort_long %&gt;% mutate(stats = gsub(&quot; &quot;, &quot;&quot;, stats)) %&gt;% separate(col = stats, into = c(&quot;rate&quot;, &quot;ci_low&quot;, &quot;ci_hi&quot;), extra = &quot;drop&quot;, convert = TRUE) %&gt;% glimpse() ## Rows: 543 ## Columns: 5 ## $ Country &lt;chr&gt; &quot;Afghanistan&quot;, &quot;Albania&quot;, &quot;Algeria&quot;, &quot;Angola&quot;, &quot;Argentina&quot;, &quot;… ## $ Year &lt;chr&gt; &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990… ## $ rate &lt;int&gt; 1340, 71, 216, 1160, 72, 58, 8, 8, 64, 46, 26, 569, 58, 33, 9… ## $ ci_low &lt;int&gt; 878, 58, 141, 627, 64, 51, 7, 7, 56, 34, 20, 446, 47, 28, 7, … ## $ ci_hi &lt;int&gt; 1950, 88, 327, 2020, 80, 65, 9, 10, 74, 61, 33, 715, 72, 38, … 4.8.4 All in one step We can chain all the steps for matmort above together, since we don’t need those intermediate data tables. matmort2&lt;- dataskills::matmort %&gt;% gather(&quot;Year&quot;, &quot;stats&quot;, `1990`:`2015`) %&gt;% mutate(stats = gsub(&quot; &quot;, &quot;&quot;, stats)) %&gt;% separate( col = stats, into = c(&quot;rate&quot;, &quot;ci_low&quot;, &quot;ci_hi&quot;), extra = &quot;drop&quot;, convert = TRUE ) %&gt;% glimpse() ## Rows: 543 ## Columns: 5 ## $ Country &lt;chr&gt; &quot;Afghanistan&quot;, &quot;Albania&quot;, &quot;Algeria&quot;, &quot;Angola&quot;, &quot;Argentina&quot;, &quot;… ## $ Year &lt;chr&gt; &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990&quot;, &quot;1990… ## $ rate &lt;int&gt; 1340, 71, 216, 1160, 72, 58, 8, 8, 64, 46, 26, 569, 58, 33, 9… ## $ ci_low &lt;int&gt; 878, 58, 141, 627, 64, 51, 7, 7, 56, 34, 20, 446, 47, 28, 7, … ## $ ci_hi &lt;int&gt; 1950, 88, 327, 2020, 80, 65, 9, 10, 74, 61, 33, 715, 72, 38, … 4.8.5 Columns by Year Spread out the maternal mortality rate by year. matmort_wide &lt;- matmort2 %&gt;% spread(key = Year, value = rate) %&gt;% print() ## # A tibble: 542 x 6 ## Country ci_low ci_hi `1990` `2000` `2015` ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 253 620 NA NA 396 ## 2 Afghanistan 745 1570 NA 1100 NA ## 3 Afghanistan 878 1950 1340 NA NA ## 4 Albania 16 46 NA NA 29 ## 5 Albania 33 56 NA 43 NA ## 6 Albania 58 88 71 NA NA ## 7 Algeria 82 244 NA NA 140 ## 8 Algeria 118 241 NA 170 NA ## 9 Algeria 141 327 216 NA NA ## 10 Angola 221 988 NA NA 477 ## # … with 532 more rows Nope, that didn’t work at all, but it’s a really common mistake when spreading data. This is because spread matches on all the remaining columns, so Afghanistan with ci_low of 253 is treated as a different observation than Afghanistan with ci_low of 745. This is where pivot_wider() can be very useful. You can set values_from to multiple column names and their names will be added to the names_from values. matmort_wide &lt;- matmort2 %&gt;% pivot_wider( names_from = Year, values_from = c(rate, ci_low, ci_hi) ) glimpse(matmort_wide) ## Rows: 181 ## Columns: 10 ## $ Country &lt;chr&gt; &quot;Afghanistan&quot;, &quot;Albania&quot;, &quot;Algeria&quot;, &quot;Angola&quot;, &quot;Argentina… ## $ rate_1990 &lt;int&gt; 1340, 71, 216, 1160, 72, 58, 8, 8, 64, 46, 26, 569, 58, 3… ## $ rate_2000 &lt;int&gt; 1100, 43, 170, 924, 60, 40, 9, 5, 48, 61, 21, 399, 48, 26… ## $ rate_2015 &lt;int&gt; 396, 29, 140, 477, 52, 25, 6, 4, 25, 80, 15, 176, 27, 4, … ## $ ci_low_1990 &lt;int&gt; 878, 58, 141, 627, 64, 51, 7, 7, 56, 34, 20, 446, 47, 28,… ## $ ci_low_2000 &lt;int&gt; 745, 33, 118, 472, 54, 35, 8, 4, 42, 50, 18, 322, 38, 22,… ## $ ci_low_2015 &lt;int&gt; 253, 16, 82, 221, 44, 21, 5, 3, 17, 53, 12, 125, 19, 3, 5… ## $ ci_hi_1990 &lt;int&gt; 1950, 88, 327, 2020, 80, 65, 9, 10, 74, 61, 33, 715, 72, … ## $ ci_hi_2000 &lt;int&gt; 1570, 56, 241, 1730, 65, 46, 10, 6, 55, 74, 26, 496, 58, … ## $ ci_hi_2015 &lt;int&gt; 620, 46, 244, 988, 63, 31, 7, 5, 35, 124, 19, 280, 37, 6,… 4.8.6 Experimentum Data Students in the Institute of Neuroscience and Psychology at the University of Glasgow can use the online experiment builder platform, Experimentum. The platform is also open source on github for anyone who can install it on a web server. It allows you to group questionnaires and experiments into projects with randomisation and counterbalancing. Data for questionnaires and experiments are downloadable in long format, but researchers often need to put them in wide format for analysis. Look at the help menu for built-in dataset dataskills::experimentum_quests to learn what each column is. Subjects are asked questions about dogs to test the different questionnaire response types. current: Do you own a dog? (yes/no) past: Have you ever owned a dog? (yes/no) name: What is the best name for a dog? (free short text) good: How good are dogs? (1=pretty good:7=very good) country: What country do borzois come from? good_borzoi: How good are borzois? (0=pretty good:100=very good) text: Write some text about dogs. (free long text) time: What time is it? (time) To get the dataset into wide format, where each question is in a separate column, use the following code: q &lt;- dataskills::experimentum_quests %&gt;% pivot_wider(id_cols = session_id:user_age, names_from = q_name, values_from = dv) %&gt;% type.convert(as.is = TRUE) %&gt;% print() ## # A tibble: 24 x 15 ## session_id project_id quest_id user_id user_sex user_status user_age current ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 34034 1 1 31105 female guest 28.2 1 ## 2 34104 1 1 31164 male registered 19.4 1 ## 3 34326 1 1 31392 female guest 17 0 ## 4 34343 1 1 31397 male guest 22 1 ## 5 34765 1 1 31770 female guest 44 1 ## 6 34796 1 1 31796 female guest 35.9 0 ## 7 34806 1 1 31798 female guest 35 0 ## 8 34822 1 1 31802 female guest 58 1 ## 9 34864 1 1 31820 male guest 20 0 ## 10 35014 1 1 31921 female student 39.2 1 ## # … with 14 more rows, and 7 more variables: past &lt;int&gt;, name &lt;chr&gt;, ## # good &lt;int&gt;, country &lt;chr&gt;, text &lt;chr&gt;, good_borzoi &lt;int&gt;, time &lt;chr&gt; The responses in the dv column have multiple types (e.g., r glossary(“integer”), r glossary(“double”), and r glossary(“character”)), but they are all represented as character strings when they’re in the same column. After you spread the data to wide format, each column should be given the ocrrect data type. The function type.convert() makes a best guess at what type each new column should be and converts it. The argument as.is = TRUE converts columns where none of the numbers have decimal places to integers. 4.9 Glossary term definition long Data where each observation is on a separate row observation All of the data about a single trial or question. value A single number or piece of data. variable A word that identifies and stores the value of some data for later use. wide Data where all of the observations about one subject are in the same row 4.10 Exercises Download the exercises. See the answers only after you’ve attempted all the questions. # run this to access the exercise dataskills::exercise(4) # run this to access the answers dataskills::exercise(4, answers = TRUE) "]
]
