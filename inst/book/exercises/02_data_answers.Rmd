---
title: 'Formative Exercise 02: MSc Data Skills Course'
author: "Psychology, University of Glasgow"
output: html_document
---

```{r setup, include=FALSE}
# please do not alter this code chunk
knitr::opts_chunk$set(echo = TRUE, message = FALSE, error = TRUE)
library(tidyverse)
```

## Vectors

The built-in vector `letters` contains the letters of the English alphabet.  Use an indexing vector of integers to extract the letters that spell 'cat'.

```{r Q1}
cat <- letters[c(3, 1, 20)]
```


The function `colors()` returns all of the color names that R is aware of. What is the length of the vector returned by this function? (Use code to find the answer.)

```{r Q2}
col_length <- length(colors())
```


The function call `runif(n, min, max)` will draw `n` numbers from a uniform distribution from `min` to `max`. If you set `n` to 1000, `min` to 0 and `max` to 1, this simulates the p-values that you would get from 1000 experiments where the null hypothesis is true. Create the following objects:

* `pvals`: 1000 simulated p-values using `runif()`
* `is_sig`: a logical vector that is `TRUE` if the corresponding element of `pvals` is less than .05, `FALSE` otherwise
* `sig_vals`: a vector of just the significant p-values
* `prop_sig`: the proportion of those p-values that were significant

```{r Q3}
set.seed(8675309) # ensures you get the same random numbers each time you run this code chunk

pvals    <- runif(1000, 0, 1)
is_sig   <- pvals < .05
sig_vals <- pvals[is_sig]
prop_sig <- length(sig_vals) / length(pvals)

# alternatively:
prop_sig <- mean(is_sig)
prop_sig <- mean(pvals < .05)
```


## Tabular Data 

Create a tibble with the columns `name`, `age`, and `country` of origin for 2 people you know.

```{r Q4}

# you can do this with the tibble function
people <- tibble(name = c("Lisa", "Robbie"),
                 age = c(43, 12),
                 country = c("US","UK") )

# also note:
# you can type this in row by row, rather than column by column,
# using the 'tribble' function
people <- tribble(~name,  ~age, ~country,
                  "Lisa",   43,  "US",
                  "Robbie", 12,  "UK")

```


Convert the built-in base R `mtcars` dataset to a tibble, and store it in the variable `mt`.

```{r Q5}
mt <- as_tibble(mtcars)
```


Create a tibble that has the structure of the table below, using the minimum typing possible. (Hint: `rep()`).  Store it in the variable `my_tbl`.

ID |  A | B   | C
--|-----|-----|---
1	| A1	| B1	| C1	
2	| A1	| B2	| C1	
3	| A1	| B1	| C1	
4	| A1	| B2	| C1	
5	| A2	| B1	| C1	
6	| A2	| B2	| C1	
7	| A2	| B1	| C1	
8	| A2	| B2	| C1

```{r Q6}
my_tbl <- tibble(ID = 1:8,
                 A = rep(c("A1", "A2"), each = 4),
                 B = rep(c("B1", "B2"), 4),
                 C = "C1")    
```


## Data Import

Download the dataset [disgust_scores.csv](https://psyteachr.github.io/msc-data-skills/data/disgust_scores.csv) and read it into a table.

```{r Q7}
# change to the location to where you put your csv file
disgust <- read_csv("https://psyteachr.github.io/msc-data-skills/data/disgust_scores.csv")
```


Override the default column specifications to skip the `id` column.

```{r Q8}
my_cols <- cols(
  id = col_skip()
)

disgust_skip <- read_csv("https://psyteachr.github.io/msc-data-skills/data/disgust_scores.csv", col_types = my_cols)
```


How many rows and columns are in the dataset from question 7?

```{r Q9}

## dim() returns a vector c(rows, cols)
dimensions <- dim(disgust)
disgust_rows <- dimensions[1]
disgust_cols <- dimensions[2]

## nrow() returns the number of rows
disgust_rows <- nrow(disgust)

## ncol() returns the number of columns
disgust_cols <- ncol(disgust)
```
